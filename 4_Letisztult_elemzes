#ez a fájl 3 fajta ökonometriai elemzést végez el

library(tseries)
library(forecast)
library(ModelMetrics)
library(neuralnet)

#0A: ADATOK BETÖLTÉSE
havi_index_gazd2 <-rbind(havi_index_gazd[1:12,], havi_index_gazd[17:237,])
rownames(havi_index_gazd2) <- c(1:233)

gazd_training <- havi_index_gazd2[1:175,]
gazd_test <- havi_index_gazd2[176:200,]
gazd_in <- havi_index_gazd2[1:200,]
gazd_out <- havi_index_gazd2[201:233,]

#0B: stacionaritás és autokorreláció vizsgálata
adf.test(havi_index_gazd2$Átlag) #stacioner (nem kell differenciázni)
Box.test(havi_index_gazd2$Átlag, type = "Ljung") #autokorrelált



#1. ARIMA
#differenciázni most nem kell, mert stacioner
#nézzünk meg egy korrelogramot
acf(havi_index_gazd2$Átlag, lag.max=20)
#ez leginkább lecseng, a 8. késleltetés után lesz 0.05-nél kisebb
pacf(havi_index_gazd2$Átlag, lag.max=20)
#leginkább 3 után törik le, de akár le is csenghet

#be kell source-olni az arima_modellezes függvényt
modell_arima <- arima_modellezes(adat = gazd_in$Átlag, ar = 8, ma = 3, d = 0)

#válasszuk ki azokat a modelleket, ahol a p érték nagyobb mint 0.05 (nem autokorrelált)
modell_arima <- modell_arima[which(modell_arima[,4] > 0.05), ]
#azaz a 0,0 modellen kívül mindegyikből kiszűrtük az autokorrelációt

#a legjobb modell legyen az, ahol a legkisebb az AIC-mutató
modell_arima[which.min(modell_arima[,3]),]
#eszerint a legjobb modell az ARIMA(1, 0, 1)

#out-of-sample előrejelzés
best_arima <- arima(gazd_in$Átlag, order = c(1, 0, 1))
arima_fcast <- forecast(object = best_arima, h = length(gazd_out$Átlag))
arima_fcast_errors <- gazd_out$Átlag - arima_fcast$mean
ModelMetrics::mse(actual = gazd_out$Átlag, predicted = arima_fcast$mean)
autoplot(arima_fcast)



#2. NEURÁLIS HÁLÓ
#be kell source-olni a neur_halo2 függvényt
nn_info <- neur_halo2(training = gazd_training$Átlag, test = gazd_test$Átlag, reps = 30)
nn_info[which.min(nn_info[,2]),]
#változó az eredmény, nyilván függ attól, hogy milyen kezdősúlyokat használ
#hd-t be kell importálni
hd[[4]]

best_nn <- elm(y = ts(gazd_in$Átlag), hd = hd[[4]], reps = 30)
nn_fcast <- forecast(object = best_nn, h = length(gazd_out$Átlag))
nn_fcast_errors <- gazd_out$Átlag - nn_fcast$mean
ModelMetrics::mse(actual = gazd_out$Átlag, predicted = nn_fcast$mean)
autoplot(nn_fcast)



#3. HIBRID MODELL
#az in_sample adatokra ugyanaz a legjobb ARIMA-modell: best_arma
arima_in_error <- best_arima$residuals

#ezt két részre bontjuk, azon fogjuk az ANN-t modellezni
arima_in_error_train <- arima_in_error[1:175]
arima_in_error_test <- arima_in_error[176:200]

#legjobb nn modell keresése a hibákon
hibrid_nn <- neur_halo2(training = arima_in_error_train, test = arima_in_error_test, reps = 30)
hibrid_nn[which.min(hibrid_nn[,2]),]

#legjobb nn modell a hibákra
best_hibrid_nn <- elm(y = ts(arima_in_error), hd = hd[[1]], reps = 30)

#az out-of-sample előrejelzéshez előrejelzek arima-val, a hibatagokat ann-nel és összeadom őket
hibrid_fcast <- as.numeric(forecast(object = best_arima, h = length(gazd_out$Átlag))$mean) +
  as.numeric(forecast(object = best_hibrid_nn, h = length(gazd_out$Átlag))$mean)
hibrid_fcast_error <- gazd_out$Átlag - hibrid_fcast
ModelMetrics::mse(actual = gazd_out$Átlag, predicted = hibrid_fcast)
autoplot(nn_fcast)


#4. DIEBOLD-MARIANO TESZT
#arima és ann pontosságának összehasonlítása
dm.test(e1 = arima_fcast_errors, e2 = nn_fcast_errors, alternative = "two.sided")

#arima és hibrid pontosságának összehasonlítása
dm.test(e1 = arima_fcast_errors, e2 = hibrid_fcast_error, alternative = "two.sided")

#ann és hibrid pontosságának összehasonlítása
dm.test(e1 = nn_fcast_errors, e2 = hibrid_fcast_error, alternative = "two.sided")
